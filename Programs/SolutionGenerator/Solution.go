// Copyright 2024 mzoesch. All rights reserved.

package SolutionGenerator

import (
    "Jafg/Shared"
    "bufio"
    "fmt"
    "os"
    "slices"
    "strings"
)

func CleanSolution() {
    if _, err := os.Stat(Shared.FullSolutionLuaPath()); !os.IsNotExist(err) {
        err := os.Remove(Shared.FullSolutionLuaPath())
        if err != nil {
            panic(err)
        }
    }

    if _, err := os.Stat(Shared.GApp.GetEngineRootDir() + "/Jafg.sln"); !os.IsNotExist(err) {
        err := os.Remove(Shared.GApp.GetEngineRootDir() + "/Jafg.sln")
        if err != nil {
            panic(err)
        }
    }

    for _, proj := range Shared.GApp.Projects {
        var targetedGeneratedFile string = proj.GetAbsoluteDirPath() + "/" + proj.Name + ".vcxproj"
        if _, err := os.Stat(targetedGeneratedFile); !os.IsNotExist(err) {
            err := os.Remove(targetedGeneratedFile)
            if err != nil {
                panic(err)
            }
        }
    }

    fmt.Println("Finished cleaning the solution.")

    return
}

func GenerateSolution() {
    PrepareBuildLua()
    WriteWorkspace()

    fmt.Println("Finished generating the solution.")

    return
}

func PostLuaRun() {
    FixAfx()

    fmt.Println("Finished post lua run.")

    return
}

func PrepareBuildLua() {
    fmt.Println("Preparing build.lua")

    if _, err := os.Stat(Shared.FullSolutionLuaPath()); os.IsNotExist(err) {
        file, err := os.Create(Shared.FullSolutionLuaPath())
        if err != nil {
            panic(err)
        }
        err = file.Close()
        if err != nil {
            panic(err)
        }
    }

    file, err := os.OpenFile(Shared.FullSolutionLuaPath(), os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0666)
    if err != nil {
        panic(err)
    }

    _, err = file.WriteString(
        "-- Copyright 2024 mzoesch. All rights reserved.\n" +
            "-- This file is automatically generated by Jafg and can be deleted with no fear.\n\n")
    if err != nil {
        panic(err)
    }

    err = file.Close()
    if err != nil {
        panic(err)
    }

    return
}
func WriteWorkspace() {
    fmt.Println("Writing workspace ...")

    file, err := os.OpenFile(Shared.FullSolutionLuaPath(), os.O_APPEND|os.O_RDWR|os.O_CREATE, 0666)
    if err != nil {
        panic(err)
    }

    _, err = file.WriteString(MakeBuildLuaContent() + "\n")
    if err != nil {
        panic(err)
    }

    err = file.Close()
    if err != nil {
        panic(err)
    }

    return
}

func MakeBuildLuaContent() string {
    var builder strings.Builder = strings.Builder{}

    builder.WriteString("language 'C++'\n")
    builder.WriteString("cppdialect 'C++20'\n")

    builder.WriteString("workspace 'Jafg'\n")
    builder.WriteString("    architecture 'x64'\n")
    builder.WriteString("    startproject 'Runtime'\n")
    builder.WriteString("    configurations { 'Debug', 'Development', 'Shipping' }\n")
    builder.WriteString("    platforms { 'Client', 'Server' }\n")

    builder.WriteString("    prebuildcommands {\n")
    builder.WriteString("        'echo Launching pre build programs ...',\n")
    builder.WriteString("        'python ../Program.py --fwd --BuildTool --pre-build --BUILD_CONFIG=%{cfg.buildcfg} " +
        "--PLATFORM=%{cfg.platform} --PROJ_NAME=%{prj.name} --CFG_KIND=%{cfg.kind} " +
        "--CFG_SYSTEM=%{cfg.system} --CFG_ARCHITECTURE=%{cfg.architecture}',\n",
    )
    builder.WriteString("        'echo Finished all pre build programs.',\n")
    builder.WriteString("    }\n")

    builder.WriteString("    postbuildcommands {\n")
    builder.WriteString("        'echo Launching post build programs ...',\n")
    builder.WriteString("        'python ../Program.py --fwd --BuildTool --post-build --BUILD_CONFIG=%{cfg.buildcfg} " +
        "--PLATFORM=%{cfg.platform} --PROJ_NAME=%{prj.name} --CFG_KIND=%{cfg.kind} " +
        "--CFG_SYSTEM=%{cfg.system} --CFG_ARCHITECTURE=%{cfg.architecture}',\n",
    )
    builder.WriteString("        'echo Finished all post build programs.',\n")
    builder.WriteString("    }\n")

    builder.WriteString("filter 'system:windows'\n")
    builder.WriteString("    systemversion 'latest'\n")
    builder.WriteString("    defines { 'PLATFORM_WINDOWS' }\n")
    builder.WriteString("    linkoptions { '/SUBSYSTEM:WINDOWS' }\n")
    builder.WriteString("filter {}\n")

    builder.WriteString("filter 'configurations:Debug'\n")
    builder.WriteString("    defines { 'IN_DEBUG' }\n")
    builder.WriteString("    runtime 'Debug'\n")
    builder.WriteString("    symbols 'On'\n")
    builder.WriteString("    optimize 'Off'\n")
    builder.WriteString("filter {}\n")

    builder.WriteString("filter 'configurations:Development'\n")
    builder.WriteString("    defines { 'IN_DEVELOPMENT' }\n")
    builder.WriteString("    runtime 'Release'\n")
    builder.WriteString("    symbols 'On'\n")
    builder.WriteString("    optimize 'On'\n")
    builder.WriteString("filter {}\n")

    builder.WriteString("filter 'configurations:Shipping'\n")
    builder.WriteString("    defines { 'IN_SHIPPING' }\n")
    builder.WriteString("    runtime 'Release'\n")
    builder.WriteString("    symbols 'Off'\n")
    builder.WriteString("    optimize 'On'\n")
    builder.WriteString("filter {}\n")

    builder.WriteString("filter 'platforms:Client'\n")
    builder.WriteString("    defines { 'AS_CLIENT' }\n")
    builder.WriteString("filter {}\n")

    builder.WriteString("filter 'platforms:Server'\n")
    builder.WriteString("    defines { 'AS_SERVER' }\n")
    builder.WriteString("filter {}\n")

    for _, proj := range Shared.GApp.Projects {
        MakeProjectSpecificLuaContent(&builder, &proj, 0)
    }

    return builder.String()
}

func MakeProjectSpecificLuaContent(builder *strings.Builder, proj *Shared.Project, indent int) {
    /* Defines for every module of a project. */
    var projDefines []string
    projDefines = append(projDefines, "CURRENT_PROJECT_NAME="+strings.ToUpper(proj.Name))
    projDefines = append(projDefines, fmt.Sprintf("PRIVATE_JAFG_CURRENT_PROJECT_PREPROC_IDENT=%s", proj.GetPreProcIntAsString()))

    for _, m := range proj.Modules {
        var modDefines []string
        modDefines = append(modDefines, "CURRENT_MODULE_NAME="+strings.ToUpper(m.GetName()))
        modDefines = append(modDefines, fmt.Sprintf("PRIVATE_JAFG_CURRENT_MODULE_PREPROC_IDENT=%s", m.GetPreProcInt()))

        var includeDirs []string
        var linkedLibs []string
        includeDirs = append(includeDirs, proj.GetRelativeDirPath()+"/Source/Public")
        includeDirs = append(includeDirs, Shared.GeneratedHeadersDir)

        var dependencies []string
        GetAllDependenciesRecursiveForModule(m, &dependencies)

        for _, publicDep := range dependencies {
            if publicDep == "CORE_DEPENDENCIES" {
                includeDirs = append(includeDirs, Shared.VendorIncludeDir)
                /* Has to be included directly and not insides the namespace. */
                includeDirs = append(includeDirs, Shared.VendorIncludeDir+"/Freetype")

                linkedLibs = append(linkedLibs, Shared.VendorLibDir+"/glfw3.lib")
                linkedLibs = append(linkedLibs, Shared.VendorLibDir+"/freetype.lib")

                continue
            }

            continue
        }

        continue
    }

    var dependencies []string
    GetAllDependenciesRecursiveForProject(proj, &dependencies)
    for _, publicDep := range dependencies {
        if publicDep == "CORE_DEPENDENCIES" {
            includeDirs = append(includeDirs, Shared.VendorIncludeDir)
            /* Has to be included directly and not insides the namespace. */
            includeDirs = append(includeDirs, Shared.VendorIncludeDir+"/Freetype")

            linkedLibs = append(linkedLibs, Shared.VendorLibDir+"/glfw3.lib")
            linkedLibs = append(linkedLibs, Shared.VendorLibDir+"/freetype.lib")

            continue
        }

        var depProj *Shared.Project = Shared.GApp.GetCheckedProjectByName(publicDep)

        includeDirs = append(includeDirs, depProj.GetRelativeDirPath()+"/Source/Public")

        if depProj.Kind.IsLaunch() {
            panic("Launch projects cannot be public dependencies. Faulty dependency: " +
                depProj.Name + " in project: " + proj.Name)
        }

        if depProj.Kind.IsShared() {
            linkedLibs = append(linkedLibs, depProj.Name)
        }

        if depProj.Kind.IsStatic() {
            linkedLibs = append(linkedLibs, depProj.Name)
        }

        continue
    }

    builder.WriteString(fmt.Sprintf("%sgroup '%s'\n", Shared.Indent(indent), strings.Join(proj.GetInclusiveParentProjectChain(), "/")))
    builder.WriteString(fmt.Sprintf("%sproject '%s'\n", Shared.Indent(indent), proj.Name))
    builder.WriteString(fmt.Sprintf("%s    location '%s'\n", Shared.Indent(indent), proj.GetRelativeDirPath()))
    builder.WriteString(fmt.Sprintf("%s    kind '%s'\n", Shared.Indent(indent), proj.Kind.ToLuaString()))

    if proj.Kind == Shared.LAUNCH {
        Shared.WriteWithIndent(builder, indent, "    filter 'system:windows'\n")
        Shared.WriteWithIndent(builder, indent, "        entrypoint 'WinMainCRTStartup'\n")
        Shared.WriteWithIndent(builder, indent, "    filter {}\n")
    }

    Shared.WriteWithIndent(builder, indent,
        fmt.Sprintf("    targetdir ('%s/%%{cfg.system}-%%{cfg.architecture}/%%{cfg.buildcfg}/%s/')\n",
        Shared.BinariesDir, proj.GetRelativeDirPath(),
    ))
    Shared.WriteWithIndent(builder, indent,
        fmt.Sprintf("    objdir ('%s/%%{cfg.system}-%%{cfg.architecture}/%%{cfg.buildcfg}/%s/')\n",
        Shared.IntermediateDir,  proj.GetRelativeDirPath(),
    ))



    Shared.WriteWithIndent(builder, indent, "    files {\n" +
        Shared.Indent(indent) + "        '" + proj.GetRelativeDirPath() + "/**.md',\n" +
        Shared.Indent(indent) + "        '" + proj.GetRelativeDirPath() + "/**.jafgproj',\n" +
        Shared.Indent(indent) + "        '" + proj.GetRelativeDirPath() + "/Source/**.h',\n" +
        Shared.Indent(indent) + "        '" + proj.GetRelativeDirPath() + "/Source/**.hpp',\n" +
        Shared.Indent(indent) + "        '" + proj.GetRelativeDirPath() + "/Source/**.c',\n" +
        Shared.Indent(indent) + "        '" + proj.GetRelativeDirPath() + "/Source/**.cpp',\n" +
        Shared.Indent(indent) + "    }\n",
    )

    Shared.WriteWithIndent(builder, indent, "    defines {\n")
    for _, define := range defines {
        builder.WriteString(Shared.Indent(indent) + "        '" + define + "',\n")
    }
    Shared.WriteWithIndent(builder, indent, "    }\n")

    Shared.WriteWithIndent(builder, indent, "    includedirs {\n")
    for _, includeDir := range includeDirs {
        builder.WriteString(Shared.Indent(indent) + "        '" + includeDir + "',\n")
    }
    Shared.WriteWithIndent(builder, indent, "    }\n")

    Shared.WriteWithIndent(builder, indent, "    links {\n")
    for _, linkedLib := range linkedLibs {
        builder.WriteString(Shared.Indent(indent) + "        '" + linkedLib + "',\n")
    }
    Shared.WriteWithIndent(builder, indent, "    }\n")

    if proj.Pch.IsUse() || proj.Pch.IsGenerate() {
        if proj.Pch.IsGenerate() {
            /*
             * To fix the below problem, we rerun this program after the lua script has been executed.
             * Fixing this manually by editing the .vcxproj files.
             * @see Arg: --PostLuaRun
             */
            Shared.WriteWithIndent(builder, indent, "    -- Somehow this does not work??\n")
            Shared.WriteWithIndent(builder, indent, "    -- The IDEA will just set the pch to /Yu but we, of course, need /Yc\n")
        }
        Shared.WriteWithIndent(builder, indent,
            "    pchheader 'CoreAFX.h'\n")
        Shared.WriteWithIndent(builder, indent,
            "    pchsource '" + Shared.GApp.GetProjectByName("Lal").GetRelativeDirPath() + "/Source/Private/CoreAFX.cpp'\n")
    }

    for _, subProj := range proj.Projects {
        MakeProjectSpecificLuaContent(builder, &subProj, indent + 4)
    }

    Shared.WriteWithIndent(builder, indent, "group ''\n")

    return
}

func GetAllDependenciesRecursiveForProject(proj *Shared.Project, dependencies *[]string) {
    if proj.Modules[0].IsPoly() {
        panic("Only non poly projects can have dependencies. Did you mean to include the dependencies in the modules config file?")
    }

    for _, publicDep := range proj.PublicDependencies {
        if slices.Contains(*dependencies, publicDep) {
            continue
        }

        *dependencies = append(*dependencies, publicDep)

        var depProj *Shared.Project = Shared.GApp.GetCheckedProjectByName(publicDep)
        GetAllDependenciesRecursiveForProject(depProj, dependencies)

        continue
    }

    return
}

func GetAllDependenciesRecursiveForModule(m Shared.Module, dependencies *[]string) {
    if m.IsPoly() {
        for _, publicDep := range m.GetPublicDependencies() {
            if slices.Contains(*dependencies, publicDep) {
                continue
            }

            *dependencies = append(*dependencies, publicDep)

            var depProj *Shared.Project = Shared.GApp.GetCheckedProjectByName(publicDep)
            GetAllDependenciesRecursiveForProject(depProj, dependencies)

            continue
        }
    } else {
        GetAllDependenciesRecursiveForProject(m.GetParent(), dependencies)
    }

    return
}

func FixAfx() {
    fmt.Println("Fixing AFX from /Yu to /Yc")

    for _, proj := range Shared.GApp.Projects {
        FixAfxForProjectRecursive(proj)
    }

    return
}

func FixAfxForProjectRecursive(proj Shared.Project) {
    for _, mod := range proj.Modules {
        var absPath string = Shared.RelPathToAbsPath(mod.GetRelDirPath())

        FixAfxForFile(absPath + "/" + mod.GetName() + ".vcxproj")

        continue
    }

    for _, subProj := range proj.Projects {
        FixAfxForProjectRecursive(subProj)
    }

    return
}

// FixAfxForFile Fixes the wrongly generated precompiled header subsystem in the solution from /Yu to /Yc.
func FixAfxForFile(absFile string) {
    fmt.Println("Fixing AFX in file: " + absFile)

    if _, err := os.Stat(absFile); os.IsNotExist(err) {
        panic("Could not find the project file: " + absFile)
    }

    file, err := os.OpenFile(absFile, os.O_RDWR, 0666)
    if err != nil {
        panic(err)
    }

    var lines []string = []string{}
    var scanner *bufio.Scanner = bufio.NewScanner(file)
    for scanner.Scan() {
        var line string = scanner.Text()
        if strings.Contains(line, "<PrecompiledHeader>Use</PrecompiledHeader>") {
            line = strings.ReplaceAll(line, "<PrecompiledHeader>Use</PrecompiledHeader>",
                "<PrecompiledHeader>Create</PrecompiledHeader>")
        }

        lines = append(lines, line)
    }

    err = file.Truncate(0)
    if err != nil {
        panic(err)
    }
    _, err = file.Seek(0, 0)
    if err != nil {
        panic(err)
    }

    for _, line := range lines {
        _, err = file.WriteString(line + "\n")
        if err != nil {
            panic(err)
        }
    }

    err = file.Close()
    if err != nil {
        panic(err)
    }

    return
}
