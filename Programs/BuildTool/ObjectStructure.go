// Copyright 2024 mzoesch. All rights reserved.

package BuildTool

import (
    "Jafg/Shared"
    "fmt"
    "os"
    "strings"
)

var ObjectStructureIndent string = "    "

var ObjectStructureCacheFileStub string = `
/*-----------------------------------------------------------------------------
    This abstract object structure file was generated by the Jafg build tool.
    Do not modify it manually.
    You may delete this file if you want. Remember to complete regenerate
    the solution afterwards (Every module must be rebuilt!).
-----------------------------------------------------------------------------*/

`

// ObjectNode represents a node in the object structure hierarchy.
type ObjectNode struct {
    Name       string
    Children   []ObjectNode
    Namespaces []string
}

func (on *ObjectNode) GetComparableName() string {
    var out string = "::"
    for idx, _ := range on.Namespaces {
        out += on.Namespaces[idx] + "::"
    }
    out += on.Name

    return out
}

type PrivateDeferredObjectNode struct {
    Name       string
    Super      string
    Namespaces []string
}

func (pdon *PrivateDeferredObjectNode) GetComparableName() string {
    var out string = "::"
    for idx, _ := range pdon.Namespaces {
        out += pdon.Namespaces[idx] + "::"
    }
    out += pdon.Name

    return out
}

// ObjectHierarchy represents the hierarchy of objects in the project.
type ObjectHierarchy struct {
    Root          *ObjectNode
    DeferredNodes []PrivateDeferredObjectNode
}

var GObjectStructure *ObjectHierarchy = nil

type ObjectHierarchyStack struct {
    s []string
}

func NewObjectHierarchyStackStack() *ObjectHierarchyStack {
    return &ObjectHierarchyStack{make([]string, 0)}
}

func (s *ObjectHierarchyStack) Push(v string) {
    s.s = append(s.s, v)
}

func (s *ObjectHierarchyStack) Pop() (string, bool /* bWasEmpty */) {
    l := len(s.s)
    if l == 0 {
        return "", true
    }

    res := s.s[l-1]
    s.s = s.s[:l-1]
    return res, false
}

func (s *ObjectHierarchyStack) Len() int {
    return len(s.s)
}

func (s *ObjectHierarchyStack) Peek() (string, bool /* bWasEmpty */) {
    l := len(s.s)
    if l == 0 {
        return "", true
    }

    return s.s[l-1], false
}

func (on *ObjectNode) FindCheckedObjectNodeByString(name string, namespaces []string) *ObjectNode {
    var node *ObjectNode = on.FindObjectNodeByString(name, namespaces)
    if node == nil {
        panic(fmt.Sprintf("Object node [%s] not found.", name))
    }

    return node
}

func ConcatNameWithNamespace(name string, namespaces []string) string {
    var out string = "::"
    for idx, _ := range namespaces {
        out += namespaces[idx] + "::"
    }
    out += name

    return out
}

// FindObjectNodeByString will search from inside namespace to outside.
func (on *ObjectNode) FindObjectNodeByString(name string, namespaces []string) *ObjectNode {
    var node *ObjectNode = on.FindObjectNodeByStringImpl(name, namespaces)
    if node != nil {
        return node
    }

    for i := len(namespaces) - 1; i >= 0; i-- {
        var newNamespaces []string = namespaces[:i]
        node = on.FindObjectNodeByStringImpl(name, newNamespaces)
        if node != nil {
            return node
        }

        continue
    }

    node = on.FindObjectNodeByNameNoNamespace(name)
    return node
}

func (on *ObjectNode) FindObjectNodeByStringImpl(name string, namespaces []string) *ObjectNode {
    if on.GetComparableName() == ConcatNameWithNamespace(name, namespaces) {
        return on
    }

    for idx, _ := range on.Children {
        if on.Children[idx].GetComparableName() == ConcatNameWithNamespace(name, namespaces) {
            return &on.Children[idx]
        }
    }

    for idx, _ := range on.Children {
        var node *ObjectNode = on.Children[idx].FindObjectNodeByString(name, namespaces)
        if node != nil {
            return node
        }
    }

    return nil
}

func (on *ObjectNode) FindObjectNodeByNameNoNamespace(name string) *ObjectNode {
    if on.Name == name {
        return on
    }

    for idx, _ := range on.Children {
        if on.Children[idx].Name == name {
            return &on.Children[idx]
        }
    }

    for idx, _ := range on.Children {
        var node *ObjectNode = on.Children[idx].FindObjectNodeByNameNoNamespace(name)
        if node != nil {
            return node
        }
    }

    return nil
}

func (on *ObjectNode) MakeCoolStringRepresentation(indent int) string {
    var out string = ""
    for i := 0; i < indent; i++ {
        out += ObjectStructureIndent
    }

    out += on.GetComparableName() + "\n"

    for _, child := range on.Children {
        out += child.MakeCoolStringRepresentation(indent + 1)
    }

    return out
}

func SortObjectNodesByName(nodes []ObjectNode) {
    for i := 0; i < len(nodes); i++ {
        for j := i + 1; j < len(nodes); j++ {
            if (nodes)[i].Name > nodes[j].Name {
                nodes[i], nodes[j] = nodes[j], nodes[i]
            }

            continue
        }

        continue
    }

    return
}

func (on *ObjectNode) RecursivelySortByName() {
    if len(on.Children) == 0 {
        return
    }

    for i := 0; i < len(on.Children); i++ {
        on.Children[i].RecursivelySortByName()
    }

    SortObjectNodesByName(on.Children)

    return
}

func (oh *ObjectHierarchy) LoadCache() {
    Shared.CheckRelativeFile(Shared.ObjectStructureCacheFile)

    var content string = Shared.ReadFileContentsFromRelativePath(Shared.ObjectStructureCacheFile)
    if len(content) == 0 {
        return
    }

    var splits []string = []string{",", "\n", "\t", "\r"}
    var words []string = SplitValidCppFile(&content, splits)

    if len(words) == 0 {
        return
    }

    if strings.HasPrefix(words[0], " ") {
        panic("Object structure cache file is illformed. Found derived object node at root.")
    }

    var stack *ObjectHierarchyStack = NewObjectHierarchyStackStack()
    for i := 0; i < len(words); i++ {
        var indentLen int = Shared.CountRunesInString(ObjectStructureIndent)

        var indentCursor int = 0
        var wordCursor int = 0

        var currentIndentationCount int = 0

        for {
            if ObjectStructureIndent[indentCursor] != words[i][wordCursor] {
                if indentCursor != 0 {
                    panic("Object structure cache file is illformed. Indentation mismatch.")
                }

                break
            }

            indentCursor++
            wordCursor++

            if indentCursor >= indentLen {
                currentIndentationCount++
                indentCursor = 0
            }

            continue
        }

        var classNameUnSplit string = words[i][wordCursor:]
        var classNameSplit []string = strings.Split(classNameUnSplit, "::")
        var idx int = 0
        for idx < len(classNameSplit) {
            if classNameSplit[idx] == "" {
                classNameSplit = append(classNameSplit[:idx], classNameSplit[idx+1:]...)
            } else {
                idx++
            }

            continue
        }

        if len(classNameSplit) == 0 {
            panic("Object structure cache file is illformed. Could not split class name.")
        }
        if len(classNameSplit) == 1 {
            panic("Object structure cache file is illformed. Could not find namespace.")
        }

        var className string = classNameSplit[len(classNameSplit)-1]
        var namespaces []string = classNameSplit[:len(classNameSplit)-1]

        if currentIndentationCount == 0 {
            if !oh.AddNewObjectNode(className, "", namespaces) {
                panic("Object structure cache file is illformed. Could not add root object node.")
            }
        } else {
            if stack.Len() == 0 {
                panic("Object structure cache file is illformed. Stack is empty.")
            }

            for stack.Len() > currentIndentationCount {
                stack.Pop()
            }

            super, bWasEmpty := stack.Peek()
            if bWasEmpty {
                panic("Object structure cache file is illformed. Stack is empty.")
            }
            if !oh.AddNewObjectNode(className, super, namespaces) {
                panic("Object structure cache file is illformed. Could not add object node. Missing super class.")
            }
        }

        if stack.Len() <= currentIndentationCount {
            stack.Push(className)
        }

        continue
    }

    return
}

func (oh *ObjectHierarchy) SaveToCache() {
    Shared.CheckRelativeFile(Shared.ObjectStructureCacheFile)
    var content string = oh.MakeCoolStringRepresentation()

    var file *os.File = Shared.OpenRelativeFile(Shared.ObjectStructureCacheFile, false, os.O_RDWR|os.O_CREATE)
    if !Shared.IsFileAndStringEqual(file, content, true) {
        fmt.Println("Object structure cache file is outdated. Writing new content.")
        Shared.TruncateFile(file)
        Shared.SeekFileBeginning(file)
        Shared.WriteToFile(file, content)
    } else {
        fmt.Println("Object structure cache file is up-to-date. Skipping re-write.")
    }

    Shared.CloseFile(file)

    return
}

func (oh *ObjectHierarchy) MakeCoolStringRepresentation() string {
    var out string = ObjectStructureCacheFileStub

    if oh.Root == nil {
        return out
    }

    out += oh.Root.MakeCoolStringRepresentation(0)

    return out
}

func (oh *ObjectHierarchy) AddDeferredObjectNode(name string, superName string, namespaces []string) {
    oh.DeferredNodes = append(oh.DeferredNodes, PrivateDeferredObjectNode{name, superName, namespaces})
    return
}

func (oh *ObjectHierarchy) ResolveDeferredNodes() {
    var cursor int = 0

    for {
        if cursor >= len(oh.DeferredNodes) {
            if len(oh.DeferredNodes) == 0 {
                return /* No deferred nodes to resolve. */
            }

            panic("Failed to resolve all deferred object nodes.")
            return
        }

        var cursorNode PrivateDeferredObjectNode = oh.DeferredNodes[cursor]
        if !oh.AddNewObjectNode(cursorNode.Name, cursorNode.Super, cursorNode.Namespaces) {
            cursor++
            continue
        }

        oh.DeferredNodes = append(oh.DeferredNodes[:cursor], oh.DeferredNodes[cursor+1:]...)
        cursor = 0

        continue
    }

    return
}

func (oh *ObjectHierarchy) AddNewObjectNode(name string, superName string, namespaces []string) bool /* bCouldAdd */ {
    if oh.Root != nil {
        var maybeNode *ObjectNode = oh.Root.FindObjectNodeByString(name, namespaces)
        if maybeNode != nil {
            if superName == "" {
                return true
            }

            superNode := oh.Root.FindCheckedObjectNodeByString(superName, namespaces)

            for idx, _ := range superNode.Children {
                if superNode.Children[idx].Name == name {
                    return true
                }

                continue
            }

            panic(fmt.Sprintf(
                "Object node [%s] is illformed. Super class [%s] does not contain child node [%s]. It is advised to regenerate the whole solution and delete the object structure cache file located at: [%s].",
                name, superName, name, Shared.GetAbsolutePathNoCheck(Shared.ObjectStructureCacheFile),
            ))

            return true
        }
    }

    if superName != "" {
        var superNode *ObjectNode = oh.Root.FindObjectNodeByString(superName, namespaces)
        if superNode == nil {
            return false
        }

        var newNode *ObjectNode = new(ObjectNode)
        newNode.Name = name
        newNode.Namespaces = namespaces
        superNode.Children = append(superNode.Children, *newNode)
    } else {
        if oh.Root == nil {
            var newNode *ObjectNode = new(ObjectNode)
            newNode.Name = name
            newNode.Namespaces = namespaces
            oh.Root = newNode
        } else {
            oh.Root.Name = name
            if oh.Root.GetComparableName() != "::"+strings.Join(namespaces, "::")+"::"+name {
                panic("Root object node has different namespaces.")
            }
        }
    }

    return true
}

func (oh *ObjectHierarchy) RecursivelySortByName() {
    if oh.Root == nil {
        return
    }

    oh.Root.RecursivelySortByName()
    return
}
