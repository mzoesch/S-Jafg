// Copyright 2024 mzoesch. All rights reserved.

package BuildTool

import (
    "Jafg/Shared"
    "fmt"
    "os"
    "strings"
)

var ObjectStructureIndent string = "    "

var ObjectStructureCacheFileStub string = `
/*-----------------------------------------------------------------------------
    This abstract object structure file was generated by the Jafg build tool.
    Do not modify it manually.
    You may delete this file if you want. Remember to complete regenerate
    the solution afterwards (Every module must be rebuilt!).
-----------------------------------------------------------------------------*/

`

// ObjectNode represents a node in the object structure hierarchy.
type ObjectNode struct {
    Name     string
    Children []ObjectNode
}

type PrivateDeferredObjectNode struct {
    Name  string
    Super string
}

// ObjectHierarchy represents the hierarchy of objects in the project.
type ObjectHierarchy struct {
    Root          *ObjectNode
    DeferredNodes []PrivateDeferredObjectNode
}

var GObjectStructure *ObjectHierarchy = nil

type ObjectHierarchyStack struct {
    s []string
}

func NewObjectHierarchyStackStack() *ObjectHierarchyStack {
    return &ObjectHierarchyStack{make([]string, 0)}
}

func (s *ObjectHierarchyStack) Push(v string) {
    s.s = append(s.s, v)
}

func (s *ObjectHierarchyStack) Pop() (string, bool /* bWasEmpty */) {
    l := len(s.s)
    if l == 0 {
        return "", true
    }

    res := s.s[l-1]
    s.s = s.s[:l-1]
    return res, false
}

func (s *ObjectHierarchyStack) Len() int {
    return len(s.s)
}

func (s *ObjectHierarchyStack) Peek() (string, bool /* bWasEmpty */) {
    l := len(s.s)
    if l == 0 {
        return "", true
    }

    return s.s[l-1], false
}

func (os *ObjectNode) FindCheckedObjectNodeByString(name string) *ObjectNode {
    var node *ObjectNode = os.FindObjectNodeByString(name)
    if node == nil {
        panic(fmt.Sprintf("Object node [%s] not found.", name))
    }

    return node
}

func (os *ObjectNode) FindObjectNodeByString(name string) *ObjectNode {
    if os.Name == name {
        return os
    }

    for idx, _ := range os.Children {
        if os.Children[idx].Name == name {
            return &os.Children[idx]
        }
    }

    for idx, _ := range os.Children {
        var node *ObjectNode = os.Children[idx].FindObjectNodeByString(name)
        if node != nil {
            return node
        }
    }

    return nil
}

func (os *ObjectNode) MakeCoolStringRepresentation(indent int) string {
    var out string = ""
    for i := 0; i < indent; i++ {
        out += ObjectStructureIndent
    }

    out += os.Name + "\n"

    for _, child := range os.Children {
        out += child.MakeCoolStringRepresentation(indent + 1)
    }

    return out
}

func SortObjectNodesByName(nodes []ObjectNode) {
    for i := 0; i < len(nodes); i++ {
        for j := i + 1; j < len(nodes); j++ {
            if (nodes)[i].Name > nodes[j].Name {
                nodes[i], nodes[j] = nodes[j], nodes[i]
            }

            continue
        }

        continue
    }

    return
}

func (os *ObjectNode) RecursivelySortByName() {
    if len(os.Children) == 0 {
        return
    }

    for i := 0; i < len(os.Children); i++ {
        os.Children[i].RecursivelySortByName()
    }

    SortObjectNodesByName(os.Children)

    return
}

func (oh *ObjectHierarchy) LoadCache() {
    Shared.CheckRelativeFile(Shared.ObjectStructureCacheFile)

    var content string = Shared.ReadFileContentsFromRelativePath(Shared.ObjectStructureCacheFile)
    if len(content) == 0 {
        return
    }

    var splits []string = []string{",", "\n", "\t", "\r"}
    var words []string = SplitValidCppFile(&content, splits)

    if len(words) == 0 {
        return
    }

    if strings.HasPrefix(words[0], " ") {
        panic("Object structure cache file is illformed. Found derived object node at root.")
    }

    var stack *ObjectHierarchyStack = NewObjectHierarchyStackStack()
    for i := 0; i < len(words); i++ {
        var indentLen int = Shared.CountRunesInString(ObjectStructureIndent)

        var indentCursor int = 0
        var wordCursor int = 0

        var currentIndentationCount int = 0

        for {
            if ObjectStructureIndent[indentCursor] != words[i][wordCursor] {
                if indentCursor != 0 {
                    panic("Object structure cache file is illformed. Indentation mismatch.")
                }

                break
            }

            indentCursor++
            wordCursor++

            if indentCursor >= indentLen {
                currentIndentationCount++
                indentCursor = 0
            }

            continue
        }

        var className string = words[i][wordCursor:]

        if currentIndentationCount == 0 {
            if !oh.AddNewObjectNode(className, "") {
                panic("Object structure cache file is illformed. Could not add root object node.")
            }
        } else {
            if stack.Len() == 0 {
                panic("Object structure cache file is illformed. Stack is empty.")
            }

            for stack.Len() > currentIndentationCount {
                stack.Pop()
            }

            super, bWasEmpty := stack.Peek()
            if bWasEmpty {
                panic("Object structure cache file is illformed. Stack is empty.")
            }
            if !oh.AddNewObjectNode(className, super) {
                panic("Object structure cache file is illformed. Could not add object node. Missing super class.")
            }
        }

        if stack.Len() <= currentIndentationCount {
            stack.Push(className)
        }

        continue
    }

    return
}

func (oh *ObjectHierarchy) SaveToCache() {
    Shared.CheckRelativeFile(Shared.ObjectStructureCacheFile)
    var content string = oh.MakeCoolStringRepresentation()

    var file *os.File = Shared.OpenRelativeFile(Shared.ObjectStructureCacheFile, false, os.O_RDWR|os.O_CREATE)
    if !Shared.IsFileAndStringEqual(file, content, true) {
        fmt.Println("Object structure cache file is outdated. Writing new content.")
        Shared.TruncateFile(file)
        Shared.SeekFileBeginning(file)
        Shared.WriteToFile(file, content)
    } else {
        fmt.Println("Object structure cache file is up-to-date. Skipping re-write.")
    }

    Shared.CloseFile(file)

    return
}

func (oh *ObjectHierarchy) MakeCoolStringRepresentation() string {
    var out string = ObjectStructureCacheFileStub

    if oh.Root == nil {
        return out
    }

    out += oh.Root.MakeCoolStringRepresentation(0)

    return out
}

func (oh *ObjectHierarchy) AddDeferredObjectNode(name string, superName string) {
    oh.DeferredNodes = append(oh.DeferredNodes, PrivateDeferredObjectNode{name, superName})
    return
}

func (oh *ObjectHierarchy) ResolveDeferredNodes() {
    var cursor int = 0

    for {
        if cursor >= len(oh.DeferredNodes) {
            if len(oh.DeferredNodes) == 0 {
                return /* No deferred nodes to resolve. */
            }

            panic("Failed to resolve all deferred object nodes.")
            return
        }

        var cursorNode PrivateDeferredObjectNode = oh.DeferredNodes[cursor]
        if !oh.AddNewObjectNode(cursorNode.Name, cursorNode.Super) {
            cursor++
            continue
        }

        oh.DeferredNodes = append(oh.DeferredNodes[:cursor], oh.DeferredNodes[cursor+1:]...)
        cursor = 0

        continue
    }

    return
}

func (oh *ObjectHierarchy) AddNewObjectNode(name string, superName string) bool /* bCouldAdd */ {
    if oh.Root != nil {
        var maybeNode *ObjectNode = oh.Root.FindObjectNodeByString(name)
        if maybeNode != nil {
            if superName == "" {
                return true
            }

            superNode := oh.Root.FindCheckedObjectNodeByString(superName)

            for idx, _ := range superNode.Children {
                if superNode.Children[idx].Name == name {
                    return true
                }

                continue
            }

            panic(fmt.Sprintf(
                "Object node [%s] is illformed. Super class [%s] does not contain child node [%s]. It is advised to regenerate the whole solution and delete the object structure cache file located at: [%s].",
                name, superName, name, Shared.GetAbsolutePathNoCheck(Shared.ObjectStructureCacheFile),
            ))

            return true
        }
    }

    if superName != "" {
        var superNode *ObjectNode = oh.Root.FindObjectNodeByString(superName)
        if superNode == nil {
            return false
        }

        var newNode *ObjectNode = new(ObjectNode)
        newNode.Name = name
        superNode.Children = append(superNode.Children, *newNode)
    } else {
        if oh.Root == nil {
            var newNode *ObjectNode = new(ObjectNode)
            newNode.Name = name
            oh.Root = newNode
        } else {
            oh.Root.Name = name
        }
    }

    return true
}

func (oh *ObjectHierarchy) RecursivelySortByName() {
    if oh.Root == nil {
        return
    }

    oh.Root.RecursivelySortByName()
    return
}
